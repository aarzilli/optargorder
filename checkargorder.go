// Copyright 2019 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Adapted from original by Alessandro Arzilli, used by permission.

package main

import (
	"debug/dwarf"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"runtime"
	"sort"
	"strings"
	"unsafe"

	"github.com/go-delve/delve/pkg/dwarf/godwarf"
	"github.com/go-delve/delve/pkg/dwarf/op"
	"github.com/go-delve/delve/pkg/dwarf/reader"
	"github.com/go-delve/delve/pkg/proc"
)

func must(err error) {
	if err != nil {
		panic(err)
	}
}

type Function struct {
	Name       string
	Entry, End uint64 // same as DW_AT_lowpc and DW_AT_highpc
	offset     dwarf.Offset
	cu         uintptr
}

var fileCache = map[string][]string{}

func getFile(path string) []string {
	if r, cached := fileCache[path]; cached {
		return r
	}

	buf, err := ioutil.ReadFile(path)
	if err != nil {
		return nil
	}
	fileCache[path] = strings.Split(string(buf), "\n")
	return fileCache[path]
}

var verbose bool
var errors bool

type argsinfo struct {
	nFunctions    int
	argumentError int
	mixedRegMem   int
	regReuse      int
	tooManyPieces int
	missingSource int
	wrongOrder    int
	missingDwarf  int
	duplicated    int
}

func main() {
	flag.BoolVar(&verbose, "v", verbose, "Say more about what is found")
	flag.BoolVar(&errors, "e", errors, "Report more detail for errors")

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, `
For a binary, %s reports the fraction of function arguments
that are described at the function's "stop at" PC.
`, os.Args[0])
	}

	flag.Parse()
	if len(flag.Args()) == 0 {
		flag.Usage()
		fmt.Fprintf(os.Stderr, "\nNo input file was provided.\n")
		return
	}

	a := &argsinfo{}

	bi := proc.NewBinaryInfo(runtime.GOOS, runtime.GOARCH)
	bi.LoadBinaryInfo(flag.Args()[0], 0, []string{})

	count := 0
	countWithSortableArgs := 0

	rdr := bi.Images[0].DwarfReader()
	rdr.Seek(0)

	for _, fn := range bi.Functions {
		if fn.Entry == 0 {
			continue
		}
		file, line, _ := bi.PCToLine(fn.Entry)

		if file == "" || file == "<autogenerated>" {
			continue
		}

		if line < 0 {
			continue
		}

		lines := getFile(file)
		if len(lines) == 0 {
			fmt.Printf("\tWARNING: SOURCE FILE NOT FOUND (%s in %s)\n", fn.Name, file)
			continue
		}
		if line >= len(lines) {
			fmt.Printf("\tWARNING: LINE %d EXCEEDS RANGE %d (%s in %s)\n", line, len(lines)-1, fn.Name, file)
			continue
		}
		dclln := strings.TrimSpace(lines[line-1])

		if !strings.Contains(dclln, "func ") {
			continue
		}

		if verbose {
			fmt.Printf("function: %s\n", fn.Name)
			fmt.Printf("\tDeclaration: %s\n", dclln)
		}
		a.nFunctions++
		count++

		sourceArgs, err := getSourceArgs(dclln)
		if err != nil {
			// maybe it spilled on the next line?
			sourceArgs, err = getSourceArgs(dclln + "\n" + strings.TrimSpace(lines[line]))
			if err != nil {
				fmt.Printf("\tWARNING: COULD NOT PARSE (%s in %s, err = %v)\n", fn.Name, file, err)
				continue
			}
		}

		_fn := (*Function)(unsafe.Pointer(&fn))

		pc := fn.PrologueEndPC()

		if verbose {
			fmt.Printf("\tprologue ends at %#x (entry: %#x)\n", pc, fn.Entry)
		}

		dwarfArgs := a.orderArgsDwarf(bi, rdr, _fn.offset)

		if a.vetArgsLocations(bi, dwarfArgs, fn.Entry, true) {
			if verbose || errors {
				fmt.Printf("\tERROR: ARGS FAILED AT ENTRY (%s in %s)\n", fn.Name, file)
			}
			continue
		}
		if a.vetArgsLocations(bi, dwarfArgs, pc, false) {
			if verbose || errors {
				fmt.Printf("\tERROR: ARGS FAILED AFTER PROLOGUE (%s in %s)\n", fn.Name, file)
			}
			continue
		}

		if verbose {
			fmt.Printf("\tDWARF arguments:\t%v\n", dwarfArgs)
			fmt.Printf("\tSource arguments:\t%v\n", sourceArgs)
		}
		countWithSortableArgs++

		if len(dwarfArgs) > len(sourceArgs) {
			a.missingSource++
			if verbose || errors {
				fmt.Printf("\tERROR: MISSING SOURCE ARGS (%s in %s, dwarfArgs=%v, sourceArgs=%v)\n", fn.Name, file, dwarfArgs, sourceArgs)
			}
			continue
		}

		if len(dwarfArgs) < len(sourceArgs) {
			a.missingDwarf++
			if verbose || errors {

				fmt.Printf("\tERROR: MISSING DWARF ARGS (%s in %s, dwarfArgs=%v, sourceArgs=%v)\n", fn.Name, file, dwarfArgs, sourceArgs)
			}
			continue
		}

		for i := range dwarfArgs {
			if dwarfArgs[i].Val(dwarf.AttrName).(string) != sourceArgs[i] {
				a.wrongOrder++
				if verbose || errors {
					fmt.Printf("\tERROR: ARGUMENT ORDER MISMATCH (%s in %s, %v vs %v)\n", fn.Name, file, dwarfArgs, sourceArgs)
				}
				break
			}
		}
	}

	if verbose {
		fmt.Printf("non-inlined non-autogenerated: %d / %d\n", count, len(bi.Functions))
		fmt.Printf("with sortable args: %d / %d\n", countWithSortableArgs, len(bi.Functions))
	}

	// type argsinfo struct {
	// 	nFunctions    int
	// 	argumentError int
	// 	tooManyPieces int
	// 	missingSource int
	// 	wrongOrder    int
	// 	missingDwarf  int
	// 	duplicated    int
	// }

	fmt.Printf("nFunctions,argumentError,mixedRegMem,regReuse,tooManyPieces,missingSource,wrongOrder,missingDwarf,duplicated,1-totalErrors/nFunctions\n")
	total := a.argumentError + a.mixedRegMem + a.regReuse + a.tooManyPieces + a.missingSource + a.wrongOrder + a.missingDwarf + a.duplicated
	fmt.Printf("%d,%d,%d,%d,%d,%d,%d,%d,%d,%f\n", a.nFunctions, a.argumentError, a.tooManyPieces, a.mixedRegMem, a.regReuse, a.missingSource, a.wrongOrder, a.missingDwarf, a.duplicated, 1.0-float64(total)/float64(a.nFunctions))

}

type arg struct {
	name string
	addr int64
}

// orderArgsDwarf picks through the DIEs of a given DWARF subprogram
// DIE looking for formal parameter DIEs and returns them as a slice.
// Formal arguments are required to appear in DWARF in the same order as
// they are declared in the program (DWARFv4 section 3.3.4, page 55).
func (a *argsinfo) orderArgsDwarf(bi *proc.BinaryInfo, rdr *reader.Reader, offset dwarf.Offset) []godwarf.Entry {
	rdr.Seek(offset)
	rdr.Next()

	args := []godwarf.Entry{}

	for {
		e, err := rdr.Next()
		if err != nil {
			must(err)
		}
		if e == nil || e.Tag == 0 {
			break
		}
		rdr.SkipChildren()
		if e.Tag != dwarf.TagFormalParameter {
			continue
		}

		if e.Val(dwarf.AttrName) == nil {
			continue
		}
		name := e.Val(dwarf.AttrName).(string)
		isvar := e.Val(dwarf.AttrVarParam).(bool)

		if isvar && len(name) > 0 && name[0] == '~' {
			continue
		}

		// skip all return arguments
		if isvar {
			continue
		}

		args = append(args, e)

	}

	return args
}

// vetArgsLocations vets the location info for the arguments 'arg' at
// instruction address pc.
//
// If entryPoint is true it also checks that the locations respect the rules
// of Go 1.17 register ABI.
//
// See:
// https://go.googlesource.com/go/+/HEAD/src/cmd/compile/abi-internal.md
// for more on how the register ABI works
func (a *argsinfo) vetArgsLocations(bi *proc.BinaryInfo, args []godwarf.Entry, pc uint64, entryPoint bool) bool {
	const _cfa = 0x1000

	regsUsed := make(map[uint64]bool)

	for _, e := range args {
		name := e.Val(dwarf.AttrName).(string)
		_, pieces, _, err := bi.Location(e, dwarf.AttrLocation, pc, op.DwarfRegisters{CFA: _cfa, FrameBase: _cfa})
		if err != nil {
			a.argumentError++
			if verbose || errors {
				fmt.Printf("\targument error for %s: %v", name, err)
			}
			return false
		}
		if !entryPoint {
			continue
		}
		nr, errmsg := a.analyzeRegisterUse(pieces, regsUsed)
		if errmsg != "" {
			if verbose || errors {
				fmt.Printf("\t%s %s, %+v", errmsg, name, pieces)
			}
			return false
		}
		if len(pieces) != 0 && nr == 0 {
			duplicatesSeen := false
			_, pieces, duplicatesSeen = coalescePieces(pieces)
			if duplicatesSeen {
				if verbose || errors {
					fmt.Printf("\tduplicates seen %s, %v", name, pieces)
				}
				a.duplicated++
				return false
			}

		}
		if len(pieces) != 0 && nr == 0 {
			a.tooManyPieces++
			if verbose || errors {
				fmt.Printf("\ttoo many pieces %s, %v", name, pieces)
			}
			return false
		}
	}

	return true
}

// analyzeRegisterUse looks for register use within the
// location piece list 'pieces', returning the number of
// regs used. If it detects errors in the list (for example,
// a mixture of registers and memory, or reuse of a
// previously used register) it returns a non-empty
// error string.
//
// NB: make sure this handles padding pieces, once Delve
// has been upgraded to deal with them.
func (a *argsinfo) analyzeRegisterUse(pieces []op.Piece, regsUsed map[uint64]bool) (int, string) {
	nr := 0
	nm := 0
	for _, p := range pieces {
		if p.IsRegister {
			nr++
			if regsUsed[p.RegNum] {
				a.mixedRegMem++
				return 0, "register reused within location"
			}
			regsUsed[p.RegNum] = true
		} else {
			nm++
		}
		if nr != 0 && nm != 0 {
			a.regReuse++
			return 0, "mix of register + memory seen"
		}
	}
	return nr, ""
}

// coalescePiece examines a non-register location piece list, looking
// for duplicates and trying to coalesce together the ranges within
// the pieces. It returns the address of the final coalesced piece if
// colaecsing worked, the final piece list, and a boolean indicating
// whether duplicate pieces were detected.
func coalescePieces(pieces []op.Piece) (int64, []op.Piece, bool) {
	duplicatesSeen := false
	sort.SliceStable(pieces, func(i, j int) bool { return pieces[i].Addr < pieces[j].Addr })
	j := 1
	for i := 1; i < len(pieces); i++ {
		if pieces[i-1] == pieces[i] {
			duplicatesSeen = true
			continue
		}
		pieces[j] = pieces[i]
		j++
	}
	pieces = pieces[:j]
	r := append(make([]op.Piece, 0, len(pieces)), pieces[0])

	for i := 1; i < len(pieces); i++ {
		if r[len(r)-1].Addr+int64(r[len(r)-1].Size) == pieces[i].Addr { // && !r[len(r)-1].IsRegister && !pieces[i].IsRegister {
			r[len(r)-1].Size += pieces[i].Size
		} else {
			r = append(r, pieces[i])
		}
	}

	if len(r) == 1 { // && !r[0].IsRegister {
		return r[0].Addr, nil, duplicatesSeen
	}

	return 0, pieces, duplicatesSeen
}

func getSourceArgs(dclln string) ([]string, error) {
	if dclln[len(dclln)-1] != '}' {
		dclln = dclln + "\n}"
	}

	source := []byte(fmt.Sprintf("package F; %s", dclln))

	var fset token.FileSet
	f, err := parser.ParseFile(&fset, "in", source, parser.AllErrors)
	if err != nil {
		return nil, err
	}

	var v getSourceArgsVisitor
	ast.Walk(&v, f)

	return v.out, nil
}

type getSourceArgsVisitor struct {
	out []string
}

func (v *getSourceArgsVisitor) Visit(node ast.Node) ast.Visitor {
	fn, ok := node.(*ast.FuncDecl)
	if !ok {
		return v
	}
	//for _, lst := range []*ast.FieldList{fn.Recv, fn.Type.Params , fn.Type.Results} {
	for _, lst := range []*ast.FieldList{fn.Recv, fn.Type.Params /*skip all return arguments*/} {
		if lst == nil {
			continue
		}
		cnt := 0
		for _, field := range lst.List {
			for _, name := range field.Names {
				if name == nil {
					v.out = append(v.out, fmt.Sprintf("~r%d", cnt))
				} else if name.Name != "_" {
					v.out = append(v.out, name.Name)
				}
				cnt++
			}
		}
	}
	return nil
}
