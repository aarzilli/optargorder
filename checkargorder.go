package main

import (
	"debug/dwarf"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"io/ioutil"
	"os"
	"runtime"
	"sort"
	"strings"
	"sync"
	"unsafe"

	"github.com/derekparker/delve/pkg/dwarf/op"
	"github.com/derekparker/delve/pkg/dwarf/reader"
	"github.com/derekparker/delve/pkg/proc"
)

func must(err error) {
	if err != nil {
		panic(err)
	}
}

type Function struct {
	Name       string
	Entry, End uint64 // same as DW_AT_lowpc and DW_AT_highpc
	offset     dwarf.Offset
	cu         uintptr
}

var fileCache = map[string][]string{}

func getFile(path string) []string {
	if r, cached := fileCache[path]; cached {
		return r
	}

	buf, err := ioutil.ReadFile(path)
	must(err)
	fileCache[path] = strings.Split(string(buf), "\n")
	return fileCache[path]
}

func main() {
	var wg sync.WaitGroup
	bi := proc.NewBinaryInfo(runtime.GOOS, runtime.GOARCH)
	bi.LoadBinaryInfo(os.Args[1], &wg)
	wg.Wait()

	count := 0
	countWithSortableArgs := 0

	rdr := bi.DwarfReader()
	rdr.Seek(0)

	for _, fn := range bi.Functions {
		if fn.Entry == 0 {
			continue
		}
		file, line, _ := bi.PCToLine(fn.Entry)

		if file == "" || file == "<autogenerated>" {
			continue
		}

		dclln := strings.TrimSpace(getFile(file)[line-1])

		if !strings.Contains(dclln, "func ") {
			continue
		}

		fmt.Printf("function: %s\n", fn.Name)
		fmt.Printf("\tDeclaration: %s\n", dclln)
		count++

		sourceArgs := getSourceArgs(dclln)

		_fn := (*Function)(unsafe.Pointer(&fn))

		dwarfArgs, ok := orderArgsDwarf(&bi, rdr, _fn.offset)
		if !ok {
			continue
		}

		fmt.Printf("\tDWARF arguments:\t%v\n", dwarfArgs)
		fmt.Printf("\tSource arguments:\t%v\n", sourceArgs)

		countWithSortableArgs++

		if len(dwarfArgs) != len(sourceArgs) {
			panic("argument list mismatch")
		}

		for i := range dwarfArgs {
			if dwarfArgs[i] != sourceArgs[i] {
				panic("argument order mismatch")
			}
		}
	}

	fmt.Printf("non-inlined non-autogenerated: %d / %d\n", count, len(bi.Functions))
	fmt.Printf("with sortable args: %d / %d\n", countWithSortableArgs, len(bi.Functions))
}

type arg struct {
	name string
	addr int64
}

func orderArgsDwarf(bi *proc.BinaryInfo, rdr *reader.Reader, offset dwarf.Offset) ([]string, bool) {
	rdr.Seek(offset)
	rdr.Next()

	const _cfa = 0x1000

	args := []arg{}
	failed := false

	for {
		e, err := rdr.Next()
		if err != nil {
			must(err)
		}
		if e == nil || e.Tag == 0 {
			break
		}
		rdr.SkipChildren()
		if e.Tag != dwarf.TagFormalParameter {
			continue
		}

		addr, pieces, _, err := bi.Location(e, dwarf.AttrLocation, 0, op.DwarfRegisters{CFA: _cfa, FrameBase: _cfa})
		if err != nil {
			fmt.Printf("\targument error for %s: %v\n", e.Val(dwarf.AttrName), err)
			failed = true
			break
		}
		if len(pieces) != 0 {
			addr, pieces = coalescePieces(pieces)
		}
		if len(pieces) != 0 {
			fmt.Printf("\ttoo many pieces %s\n", e.Val(dwarf.AttrName))
			failed = true
			break
		}

		args = append(args, arg{e.Val(dwarf.AttrName).(string), addr})
	}

	sort.Slice(args, func(i, j int) bool {
		return args[i].addr < args[j].addr
	})

	if failed {
		fmt.Printf("\tARGS FAILED\n")
		return nil, false
	}

	r := make([]string, len(args))

	for i := range args {
		r[i] = args[i].name
	}

	return r, true
}

func coalescePieces(pieces []op.Piece) (int64, []op.Piece) {
	r := append(make([]op.Piece, 0, len(pieces)), pieces[0])

	for i := 1; i < len(pieces); i++ {
		if r[len(r)-1].Addr+int64(r[len(r)-1].Size) == pieces[i].Addr && !r[len(r)-1].IsRegister && !pieces[i].IsRegister {
			r[len(r)-1].Size += pieces[i].Size
		} else {
			r = append(r, pieces[i])
		}
	}

	if len(r) == 1 && !r[0].IsRegister {
		return r[0].Addr, nil
	}

	return 0, pieces
}

func getSourceArgs(dclln string) []string {
	if dclln[len(dclln)-1] != '}' {
		dclln = dclln + "\n}"
	}

	source := []byte(fmt.Sprintf("package F; %s", dclln))

	var fset token.FileSet
	f, err := parser.ParseFile(&fset, "in", source, parser.AllErrors)
	must(err)

	var v getSourceArgsVisitor
	ast.Walk(&v, f)

	return v.out
}

type getSourceArgsVisitor struct {
	out []string
}

func (v *getSourceArgsVisitor) Visit(node ast.Node) ast.Visitor {
	fn, ok := node.(*ast.FuncDecl)
	if !ok {
		return v
	}
	for _, lst := range []*ast.FieldList{fn.Recv, fn.Type.Params, fn.Type.Results} {
		if lst == nil {
			continue
		}
		cnt := 0
		for _, field := range lst.List {
			for _, name := range field.Names {
				if name == nil {
					v.out = append(v.out, fmt.Sprintf("~r%d", cnt))
				} else {
					v.out = append(v.out, name.Name)
				}
				cnt++
			}
		}
	}
	return nil
}
